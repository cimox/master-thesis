<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Streaming tree</title>
    <style>

        .node circle {
            stroke: black;
            stroke-width: 2.5px;
        }

        .node text {
            color: black;
        }

        .link {
            fill: none;
            stroke: #000;
        }
    </style>
    <script type="text/javascript" src="lib/d3_v3.js"></script>
    <script type="text/javascript" src="lib/lodash.min.js"></script>
    <script type="text/javascript" src="js/utils.js"></script>
    <script type="text/javascript" src="js/tree.js"></script>
</head>
<body>
<script>

    var width = 800,
        height = 800;

    var tree = d3.layout.tree()
        .size([width - 20, height - 20]);

    var root = {},
        nodes = tree(root);

    var nodeIdsLookup = {}, nodePosition = 0;

    root.parent = root;
    root.px = root.x;
    root.py = root.y;

    var diagonal = d3.svg.diagonal();
    //        .projection(function (d) { return [d.y, d.x] });

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", "translate(10,10)");

    var node = svg.selectAll(".node"),
        link = svg.selectAll(".link");

    var duration = 750;

    function addTreeIncrement(treeIncrement) {
        // Add a new node to its parent if exists.
        if (nodes.length == 1) {
            addChildren(root, treeIncrement);
        }
//        else if (getParentNode(treeIncrement.id) && treeIncrement.id != "root") {
////            TODO: fix this nodes lookup table
//            console.log('Updating data of existing node ' + treeIncrement.id);
//            var nodeToUpdate = nodes[nodeIdsLookup[treeIncrement.id]];
//            updateNodeData(nodeToUpdate, treeIncrement);
//            updateTree();
//        }
        else if (treeIncrement.id != "root") {
            addChildren(getParentNode(root, treeIncrement.parent), treeIncrement);
        }

        // Recompute the layout and data join.
        node = node.data(tree.nodes(root), function (d) {
            return d.id;
        });
        link = link.data(tree.links(nodes), function (d) {
            return d.source.id + "-" + d.target.id;
        });
        renderLabels(node);

        // Add entering links in the parentâ€™s old position.
        link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function (d) {
                var o = {
                    x: d.source.px,
                    y: d.source.py
                };
                return diagonal({source: o, target: o});
            });

        // Transition nodes and links to their new positions.
        svg.transition()
            .duration(duration)
            .selectAll(".link")
            .attr("d", diagonal);
    }

    function updateTree() {
        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse(),
            links = tree.links(nodes);

        var node = svg.selectAll("g.node")
            .data(nodes, function (d) {
                return d.id || (d.id = ++i);
            });

        // Update nodes
        node.exit().remove()
            .transition()
            .duration(duration)
            .attr("transform", function (d) {
                d.px = d.x; d.py = d.y;
                return "translate(" + d.x + "," + d.y + ")";
            });

        node.transition()
            .duration(duration)
            .attr("transform", function (d) {
                d.px = d.x; d.py = d.y;
                return "translate(" + d.x + "," + d.y + ")";
            });

        node.select("text")
            .text(function (d) {
                if (_.isEqual(d.id, "root")) return "root";
                if (d.split) {
                    return d.split.attribute + " " + d.split.operator + " " +
                        d.split.operand.toFixed(2);
                }
                return d.weights;
            });

        // Update links
        var link = svg.selectAll("path.link")
            .data(links, function (d) {
                return d.target.id;
            });
        link.exit().remove();

        svg.transition()
            .duration(duration)
            .selectAll(".link")
            .attr("d", diagonal);
    }

    var timeout = 750;
    function bft(tree, callback) {
        var queue = [];

        queue.push(tree);
        while (queue.length !== 0) {
            var element = queue.shift();
//            console.log('Processing element ' + element.id);
            function renderElement(element, timeout) {
                (function () {
                    setTimeout(function () {
                        callback(element);
                    }, timeout);
                })();
            }

            renderElement(element, timeout);
            timeout += 750;

            if (element.children !== undefined) {
                for (var i = 0; i < element.children.length; i++) {
                    queue.push(element.children[i]);
                }
            }
        }
    }

    d3.json("data/c.json", function (error, treeData) {
        if (error) throw error;

        for (var i in treeData) {
            console.log(treeData[i]);
            bft(treeData[i], addTreeIncrement);
        }
    });

    function addIncrement() {
        d3.json("data/b.json", function (error, treeData) {
            if (error) throw error;

            bft(treeData, addTreeIncrement);
        });
    }

    function removeNodeBtn() {
        console.log('Removing node');

        root.children.splice(1, 1);

        updateTree();
    }

    function updateBtn() {
        updateTree();
    }

</script>

<div class="control-group">
    <button onclick="addIncrement()">Add increment</button>
    <button onclick="removeNodeBtn()">Remove node</button>
    <button onclick="updateBtn()">update</button>
</div>

</body>
</html>